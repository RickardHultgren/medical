<html>
<head>
    <head>
        <link rel="stylesheet" href="https://pyscript.net/alpha/pyscript.css" />
         <script defer src="https://pyscript.net/alpha/pyscript.js"></script>

		<link rel="stylesheet" href="styles.css">
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
		<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Signika+Negative:300,400,600,700&amp;lang=en" />	
<script src="https://d3js.org/d3.v7.min.js"></script>
<!--script src="https://d3js.org/d3.v6.min.js"></script-->
<!--script src="https://d3js.org/d3.v5.min.js"></script-->
<script src="https://unpkg.com/@hpcc-js/wasm@0.3.11/dist/index.min.js"></script>
<script src="https://unpkg.com/d3-graphviz@3.0.5/build/d3-graphviz.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.10.7/brython.min.js"></script>
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.10.7/brython_stdlib.min.js">
</script>	

			
    </head>
<body style="margin:3em;"  onload="brython()">
<script type="text/python">
from browser import document, bind, html, alert, window
from javascript import this
import urllib.request
      


			
#???			
addresses = list()
import subprocess

import sys

#for the graph function:
import os



#regex
import re

#Web version skip
#			theturn = 1

def recursive_parse(node,substitutions):
	if hasattr(node.left,"id"):
		if node.left.id in substitutions.keys():
			node.left = substitutions[node.left.id]
	else:
		recursive_parse(node.left,substitutions)

	if hasattr(node.right,"id"):
		if node.right.id in substitutions.keys():
			node.right = substitutions[node.right.id]
	else:
		recursive_parse(node.right,substitutions)



# Variables for " 1. Program call through bash-CLI.".
CLI_filename = ""
argv_len = len(sys.argv)
filenames = list()
filename = ""



# List of statements that should be executed during step 0:
starts = list()

# Steps given from the CLI-command:
steps = 0

local_files = True

# Depending on what the interpreter is supposed to do different modes are used:
mode_graph = False
mode_state = False
mode_exe = False
mode_show = False
mode_map = False

#Graphviz for html variant
d3 = window.d3

# Check if all script files are loaded:
filecheck = False

# Lists of option:
exe_list = list()
show_list = list()
map_list = list()
series = list()
substates = list()
nextstates = list()
specs = list()

# LYMPHA-langugage grammar:
global_relative_variable1 = None
global_relative_variable2 = None
operator1 = None
statement_value = str()
statement_flow = int()

# Objects to be executed:
exe_objects = list()

CLIcom_segment = 0



#Construction of the section model of the linked list.
class Statement(dict):
	MARKER = object()

	def __init__(self, value=None):
		if value is None:
			pass
		elif isinstance(value, dict):
			for key in value:
				self.__setitem__(key, value[key])
		else:
			raise TypeError('expected dict')

	def __setitem__(self, key, value):
		if isinstance(value, dict) and not isinstance(value, Statement):
			value = Statement(value)
		super(Statement, self).__setitem__(key, value)

	def __getitem__(self, key):
		found = self.get(key, Statement.MARKER)
		if found is Statement.MARKER:
			found = Statement()
			super(Statement, self).__setitem__(key, found)
		return found

	__setattr__, __getattr__ = __setitem__, __getitem__


# A list of all objects:
object_list = dict()
object_list = Statement(object_list)

#class Statement:
#    def __init__(self, flow, name, global_relative_variable1, global_relative_variable2, statement_flow, statement_value, operator1, next_list, binary_list, operation, spec_list):
#        
#        self.flow = int(flow)
#                
#        #list of next nodes:
#        #next_list = next_list
#       self.next_list = list(next_list)
#        
#        #list of specifications:
#        #spec_list = spec_list
#        self.spec_list = list()#
#
#        #list of contents:
#        #binary_list = binary_list
#        self.binary_list = list(binary_list)#
#
#        #should the binary_list be counted as a sum or an equation?
#        #self.summerize = summerize
#        self.operation = operation  #This holds the operation that are found in the string (left to right)
#        
#        #name
#        self.name = name
#        
#        #tipping point
#        self.global_relative_variable1 = global_relative_variable1
#
#        #tipping point
#        self.global_relative_variable2 = global_relative_variable2
#        
#        #relational operator
#        self.operator1 = operator1#
#
#        #statement_flow
#        self.statement_flow = statement_flow
#        #if statement_flow == 0 :self.statement_flow = 0
#        #else: self.statement_flow = 1#
#
#        #statement_value
#        self.statement_value = statement_value

#def prevwfunc(ev):
def prevwfunc():
	#alert("prevfun 1")
	global d3
	global argv_len 
	global filename 
	global filenames 

	global filecheck 

	global exe_list 

	global map_list
	global series 
	global substates 
	#global nextstates 
	global specs 
	#global global_relative_variable1 
	global global_relative_variable2 
	
	global statement_flow 
	global statement_value
	#####alert("x7")
	global object_list 
	global exe_objects 
	
	global starts
	global show_list
	global steps
	graphstr = 'digraph lympha {\nnode [shape=record];'
	#ADDED INT IN INT(STEPS)
	#alert("prevfun 2")
	temporary_starts =  list()
	for start_item in document.select(".theStarts"):
		#alert("prevfun 3")
		starts.append(start_item.value)
		temporary_starts.append(start_item.value)

	temp_nextstates = list()

	for step in range(0, int(steps)):
		#alert("prevfun 4")
		for start in temporary_starts:
			for key in range(0,len(object_list)):
				endstring = str()
				strr=str("%s" % object_list[key].name)
				strr = re.sub("\s+", "", strr.strip())
				pre_statement_flow = 1
				if str(start) == strr :
					graphstr += ('"%s" [label="step %s: %s", fillcolor=white, style=filled] ; \n' % (start,step+1,start))
					for next_object in object_list[key].next_list :
						if object_list[key].name != next_object :
							graphstr += ('"%s" -> "%s" ; \n' % (start,next_object))
							temp_nextstates.append(next_object)
		for start in temporary_starts :
			for k in range(0,len(object_list)):
				if object_list[k].name==start:
					for nexting in object_list[k].next_list :
						for l in range(0,len(object_list)):  
							if object_list[l].name == nexting :          
								nextstates.append(nexting)									
			for k in range(0,len(object_list)):
				if object_list[k].name==start:
					for nexting in object_list[k].next_list :
						for l in range(0,len(object_list)):  
							if object_list[l].name == nexting :          
								if object_list[k].flow  == 0 or object_list[k].statement_flow == 0 :
									object_list[l].flow = 0
									object_list[l].statement_flow = 0
			for k in range(0,len(object_list)):

				if object_list[k].name==start:
					for nexting in object_list[k].next_list :
						for l in range(0,len(object_list)):  
							if object_list[l].name == nexting :          
								if object_list[k].flow  == 1 or object_list[k].statement_flow == 1 :
									object_list[l].flow = 1
									object_list[l].statement_flow = 1
		del temporary_starts[:]
		#starts = list()                           
		for nexting in temp_nextstates: 
			if nexting not in temporary_starts: 
				temporary_starts.append(nexting) 
		del temp_nextstates[:]
	graphstr += '}'
	#alert("prevfun 10")
	try:
						#graphstr += "}"
						#d3 = window.d3

						svg1 = d3.select("#graphpreview")
						svg1.append("p").graphviz().renderDot(graphstr)

	except:	
						pass        
	
#Function for running the linked list.
def mapfunc():
	global d3
	#global UI
	#global CLI_filename 
	global argv_len 
	global filename 
	global filenames 
	global mode_graph 
	global mode_state 
	global filecheck 
	global mode_exe 
	global mode_show 
	global mode_map 
	global exe_list 
	#global show_list 
	global map_list 
	global series 
	global substates 
	#global nextstates 
	nextstates  = list()
	global specs 
	#global global_relative_variable1 
	global global_relative_variable2 
	#global operator1 
	global statement_flow 
	global statement_value
	global object_list 
	global exe_objects 

	global starts
	global show_list
	global steps
	#if mode_graph == True:
	graphstr = 'digraph lympha {\nnode [shape=record];'
	#ADDED INT IN INT(STEPS)
	for step in range(0, int(steps)):
		#nextstates = list()
		checked = 0 
		###alert("zero")
		for start in starts:
			for key in range(0,len(object_list)):
				endstring = str()
				strr=str("%s" % object_list[key].name)
				strr = re.sub("\s+", "", strr.strip())
				
				###alert("A1 name:%s  ; datatype:%s  ; flow:%s  ; statement_flow:%s" % (object_list[key].name, object_list[key].datatype, object_list[key].flow, object_list[key].statement_flow ))

				#if object_list[key].name[-1] == "?":
				#	pre_statement_flow = 0
				#else:
				#	if object_list[key].flow == 1 or object_list[key].statement_flow == 1:
				#		pre_statement_flow = 1
				#	else:
				#		pre_statement_flow = 0

				#	if str(start) == strr :
				#alert("checkaaa1")
				if str(start) == strr :
					#alert("checkaaa1")
					if object_list[key].flow == 0 or object_list[key].statement_flow == 0:
						#alert("checkaaa2")
						pre_statement_flow = 0
					else:
						#alert("checkaaa3")
						if object_list[key].name[-1] != "?":
							pre_statement_flow = 0

							if step == 0 :
								object_list[key].flow = 1
								object_list[key].statement_flow = 1

						else:
							if object_list[key].flow == 1 or object_list[key].statement_flow == 1:
								pre_statement_flow = 1
							else:
								pre_statement_flow = 0

							document <= ("NAME: %s" % object_list[key].name)
				
							#For binaries
							if object_list[key].datatype == "bina":	
									#alert("bina")
									if object_list[key].statement_value == "1B" :
										pre_statement_flow = 1
										object_list[key].statement_flow = 1
									if object_list[key].statement_value == "0B" :
										pre_statement_flow = 0
										object_list[key].statement_flow = 0
									checked = 1

							#For binary evaluation
							###alert("bina eval")
							#if object_list[key].datatype == "bineval" :# and len(object_list[key].binary_list) >= 1:
							if len(object_list[key].binary_list) >= 1:
								###alert("bina eval")
								pre_statement_flow = 0
								subfactors = list()
								#Convecrting variables into values
								for binobj in object_list[key].binary_list :
									for item in range(0,len(object_list)) :
										thename = object_list[item].name
										thename = str(thename)
										#thename = thename[1:]
										#thename = thename[:1]
										#thename = re.sub("\s+", "", thename.strip())
										#if object_list[item].name == binobj.replace(" ","") :
										if thename == ("%s" % binobj.replace(" ","")) :
											subfactors.append(int(int(object_list[item].value[:-1])))
								sum1 = subfactors.count(1)
								sum0 = subfactors.count(0)
								###alert("%s %s %s" % (object_list[key].operator1, object_list[key].global_relative_variable1), int(sum1))
								if object_list[key].operator1 != None: # and object_list[key].statement_flow == None :
									if object_list[key].operator1 == "equiv" and int(object_list[key].global_relative_variable1) == int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "geq" and int(object_list[key].global_relative_variable1) >= int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "leq" and int(object_list[key].global_relative_variable1) <= int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "no" and int(object_list[key].global_relative_variable1) != int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "g" and int(object_list[key].global_relative_variable1) > int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "l" and int(object_list[key].global_relative_variable1) < int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									else:
										pre_statement_flow = 0
									print(object_list[key].statement_value)
								object_list[key].statement_flow = int(pre_statement_flow)       
								checked = 1

							#For binary equations:
							#if object_list[key].datatype == "bineval" and len(object_list[key].binary_list) >= 1:
							#	###alert("begin B2")
								#pre_statement_flow = 0
								#subfactors = list()
								#Convecrting variables into values
								#for binobj in object_list[key].binary_list :
								#		for item in range(0,len(object_list)) :
								#			thename = object_list[item].name
								#			thename = str(thename)
								#		 #thename = thename[1:]
								#		 #thename = thename[:1]
								#		 #thename = re.sub("\s+", "", thename.strip())
								#		 #if object_list[item].name == binobj.replace(" ","") :
								#			if thename == ("%s" % binobj.replace(" ","")) :
								#				subfactors.append(int(object_list[item].statement_flow))
								#sum1 = subfactors.count(1)
								#sum0 = subfactors.count(0)
								#pre_statement_flow = 1

								###alert("begin B3")
								if object_list[key].operator1 != None: # and object_list[key].statement_flow == None :

									if object_list[key].operator1 == "equiv" and int(object_list[key].global_relative_variable1) == int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "geq" and int(object_list[key].global_relative_variable1) >= int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "leq" and int(object_list[key].global_relative_variable1) <= int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "no" and int(object_list[key].global_relative_variable1) != int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "g" and int(object_list[key].global_relative_variable1) > int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									elif object_list[key].operator1 == "l" and int(object_list[key].global_relative_variable1) < int(sum1):
										pre_statement_flow = 1
										object_list[key].statement_value = ("score: %s\nthreshold: %s" % (sum1, object_list[key].global_relative_variable1))
									else:
										pre_statement_flow = 0
								###alert("begin B4")
								object_list[key].statement_flow = int(pre_statement_flow)   
								object_list[key].flow = int(pre_statement_flow)        
								checked = 1

							###alert("begin C1")
							#For equations
							if object_list[key].datatype == "valu":
							#if object_list[key].statement_value != "" and object_list[key].operator1 == "" :

										#comp = re.compile(r'(\d*)', re.IGNORECASE)
										endstring = str()
										string = (object_list[key].statement_value.replace(" ",""))
										pattern = re.compile(r'([\=\+\-\/\*\(\)])')      
										iteratorUntouched = re.split(pattern, string)
							
										eqlist = list()
										for varWord in iteratorUntouched:
											print(varWord)
											checked = 0
											for objWord in range(len(object_list)):
												thename = object_list[objWord].name
												if thename == varWord:
													eqlist.append(object_list[objWord].statement_value)
													checked = 1
											if checked == 0:
												eqlist.append(varWord) 
										endstring = (("").join(eqlist))                             
										endstring = str(eval(str(endstring)))
										object_list[key].statement_value = endstring


							#For float equations
							if object_list[key].datatype == "valu" :                
							#else:
										#comp = re.compile(r'(\d*)', re.IGNORECASE)
										endstring = str()
										string = (object_list[key].statement_value.replace(" ",""))
  
										#pattern = re.compile(r'([\=\+\-\/\*\(\)])')
										#iteratorFresh = re.split(pattern, string)
										iteratorFresh = re.split("(?:(?:[^a-zA-Z])|(?:[^a-zA-Z]+))|(?:[^a-zA-Z]+)", string)

										eqlist = list()
										for varWord in iteratorFresh:
											checked = 0
											for objWord in range(len(object_list)):
												thename = object_list[objWord].name
												if thename == varWord:
													eqlist.append(object_list[objWord].statement_value)
													checked = 1
											if checked == 0:
												eqlist.append(varWord) 
										endstring = (("").join(eqlist))
										#Bugprone euation line:  
										#endstring = str(eval(str(endstring)))
										
										object_list[key].statement_value = endstring
										#endnum = float()
										#endnum = float(eval(str(endstring)))
										endnum = endstring
										pre_statement_flow = 0
										try:
											op = "failed"
											if object_list[key].operator1 == "equiv" and int(object_list[key].global_relative_variable1) == int(str(endnum)):
													op = "=="
													pre_statement_flow = 1
											elif object_list[key].operator1 == "leq" and int(object_list[key].global_relative_variable1) >= int((endnum)):
													op = ">="
													pre_statement_flow = 1
											elif object_list[key].operator1 == "geq" and (int(object_list[key].global_relative_variable1) <= int(str(endnum))):
													op = "<="
													pre_statement_flow = 1
											elif object_list[key].operator1 == "no" and int(object_list[key].global_relative_variable1) != int(str(endnum)):
													op = "!="
													pre_statement_flow = 1
											elif object_list[key].operator1 == "g" and int(object_list[key].global_relative_variable1) < int(str(endnum)):

													op = "<"
													pre_statement_flow = 1
											elif object_list[key].operator1 == "l" and int(object_list[key].global_relative_variable1) > int(str(endnum)):
													op = ">"
													pre_statement_flow = 1
											else:
													pre_statement_flow = 0
											document <= html.BR()
											document <= str("%s = "%object_list[key].name)

											document <= html.BR()
										except:
											#endnum = float(eval(str(endstring)))
											endnum = endstring
											op = "failed"
											if object_list[key].operator1 == "equiv" and float(object_list[key].global_relative_variable1) == float(str(endnum)):
													op = "=="
													pre_statement_flow = 1
											elif object_list[key].operator1 == "leq" and float(object_list[key].global_relative_variable1) >= float((endnum)):
													op = ">="
													pre_statement_flow = 1
											elif object_list[key].operator1 == "geq" and (float(object_list[key].global_relative_variable1) <= float(str(endnum))):
													op = "<="
													pre_statement_flow = 1
											elif object_list[key].operator1 == "no" and float(object_list[key].global_relative_variable1) != float(str(endnum)):
													op = "!="
													pre_statement_flow = 1
											elif object_list[key].operator1 == "g" and float(object_list[key].global_relative_variable1) < float(str(endnum)):
													op = "<"
													pre_statement_flow = 1
											elif object_list[key].operator1 == "l" and float(object_list[key].global_relative_variable1) > float(str(endnum)):
													op = ">"
													pre_statement_flow = 1
											else:
													pre_statement_flow = 0

											document <= html.BR()
											document <= str("%s = "%object_list[key].name)
											
											document <= html.BR()

										object_list[key].statement_flow = int(pre_statement_flow)
   
							###alert("begin D1")
							#For nonbinar-evaluations
							if object_list[key].datatype == "nonbineval" :
							
										#comp = re.compile(r'(\d*)', re.IGNORECASE)
										endstring = str()
										string = (object_list[key].statement_value.replace(" ",""))
										pattern = re.compile(r'([\=\+\-\/\*\(\)])')
										iteratorUntouched = re.split(pattern, string)
							
										eqlist = list()
										for varWord in iteratorUntouched:
											print(varWord)
											checked = 0
											for objWord in range(len(object_list)):
												thename = object_list[objWord].name
												if thename == varWord:
													eqlist.append(object_list[objWord].statement_value)
													checked = 1
											if checked == 0:
												eqlist.append(varWord) 
										endstring = (("").join(eqlist))                             
										endstring = str(eval(str(endstring)))
										object_list[key].statement_value = endstring
										endnum = float()
										endnum = float(eval(str(endstring)))

										pre_statement_flow = 0
										try:
											if object_list[key].operator1 == "equiv" and int(object_list[key].global_relative_variable1) == int(str(endnum)):
													print ("%s == %s ; exe" % (int(object_list[key].global_relative_variable1), int(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "leq" and int(object_list[key].global_relative_variable1) >= int((endnum)):
													print ("%s >= %s ; exe" % (int(object_list[key].global_relative_variable1), int(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "geq" and (int(object_list[key].global_relative_variable1) <= int(str(endnum))):
													print ("%s <= %s ; exe" % (int(object_list[key].global_relative_variable1), int(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "no" and int(object_list[key].global_relative_variable1) != int(str(endnum)):
													print ("%s != %s ; exe" % (int(object_list[key].global_relative_variable1), int(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "g" and int(object_list[key].global_relative_variable1) < int(str(endnum)):
													print ("%s < %s ; exe" % (int(object_list[key].global_relative_variable1), int(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "l" and int(object_list[key].global_relative_variable1) > int(str(endnum)):
													print ("%s > %s ; exe" % (int(object_list[key].global_relative_variable1), int(str(endnum))))
													pre_statement_flow = 1
											else:
													pre_statement_flow = 0

										except:
											endnum = float(eval(str(endstring)))

											if object_list[key].operator1 == "equiv" and float(object_list[key].global_relative_variable1) == float(str(endnum)):
													print ("%s == %s ; exe" % (float(object_list[key].global_relative_variable1), float(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "leq" and float(object_list[key].global_relative_variable1) <= float((endnum)):
													print ("%s <= %s ; exe" % (float(object_list[key].global_relative_variable1), float(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "geq" and (float(object_list[key].global_relative_variable1) >= float(str(endnum))):
													print ("%s >= %s ; exe" % (float(object_list[key].global_relative_variable1), float(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "no" and float(object_list[key].global_relative_variable1) != float(str(endnum)):
													print ("%s != %s ; exe" % (float(object_list[key].global_relative_variable1), float(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "g" and float(object_list[key].global_relative_variable1) < float(str(endnum)):
													print ("%s < %s ; exe" % (float(object_list[key].global_relative_variable1), float(str(endnum))))
													pre_statement_flow = 1
											elif object_list[key].operator1 == "l" and float(object_list[key].global_relative_variable1) > float(str(endnum)):
													print ("%s > %s ; exe" % (float(object_list[key].global_relative_variable1), float(str(endnum))))
													pre_statement_flow = 1
											else:
													pre_statement_flow = 0

					object_list[key].statement_flow = int(pre_statement_flow)

					#alert("begin E1")
					#if object_list[key].statement_flow == 0 or object_list[key].flow == 0 :    
					if object_list[key].flow != 1 :    
						###alert("A8 IF 0 name:%s  ; datatype:%s  ; flow:%s  ; #statement_flow:%s" % (object_list[key].name, object_list[key].datatype, object_list[key].flow, object_list[key].statement_flow ))									

						#object_list[key].flow = 0 
						#object_list[key].statement_flow = 0 
						#pre_statement_flow = 0

						object_list[key].statement_flow = int(pre_statement_flow)        
						object_list[key].flow = int(pre_statement_flow)        
					#if object_list[key].flow == 0 :
					#	object_list[key].statement_flow = 0 

					if step == 0 :
						object_list[key].flow = 1
						object_list[key].statement_flow = 1


						#DELTETED GRAPHMODE-IF
					if object_list[key].statement_flow == 0:

							graph_string=""
							if object_list[key].datatype == "bina" :
								graph_string="0B"
							if object_list[key].datatype == "bineval" :
								graph_string=object_list[key].statement_value
							if object_list[key].datatype == "nonbineval" :
								graph_string=("score: %s" % (object_list[key].statement_value))
							if object_list[key].datatype == "valu" :                                
								graph_string=object_list[key].statement_value
							graphstr += ('"%s" [label="step %s: %s\\n%s", fillcolor=white, style=filled] ; \n' % (start,step+1,start,str(graph_string)))
	
							#graphstr += ('"%s" [label="step %s: %s\\n%s"] \n' % (start,step+1,start,graph_string)) 
					###alert("before draw")
					if object_list[key].statement_flow == 1:

						graph_string=""
						if object_list[key].datatype == "bina" :
							graph_string="1B"
						if object_list[key].datatype == "bineval" :
							graph_string=object_list[key].statement_value
						if object_list[key].datatype == "nonbineval" :
							graph_string=("score: %s" % (object_list[key].statement_value))
						if object_list[key].datatype == "valu" :                                
							graph_string=object_list[key].statement_value

						graphstr += ('"%s" [label="step %s: %s\\n%s", fillcolor=yellow, style=filled] ; \n' % (start,step+1,start,str(graph_string)))

					###alert("before draw2")									
					try:	
						for next_object in object_list[key].next_list :

							if object_list[key].name != next_object :
								graphstr += ('"%s" -> "%s" ; \n' % (start,next_object))
								nextstates.append(next_object)
					except:
						pass

		#alert("before draw2.1")	
		for start in starts :
			for k in range(0,len(object_list)):
				if object_list[k].name==start:
					for nexting in object_list[k].next_list :
						for l in range(0,len(object_list)):  
							if object_list[l].name == nexting :          
								nextstates.append(nexting)									
			###alert("before draw2.2")	
			if checked == 0:
				for k in range(0,len(object_list)):
					if object_list[k].name==start:
						for nexting in object_list[k].next_list :
							for l in range(0,len(object_list)):  
								if object_list[l].name == nexting :          
									if object_list[k].flow  == 0 or object_list[k].statement_flow == 0 :
										object_list[l].flow = 0
										object_list[l].statement_flow = 0
				###alert("before draw2.3")	
				for k in range(0,len(object_list)):
					if object_list[k].name==start:
						for nexting in object_list[k].next_list :
							for l in range(0,len(object_list)):  
								if object_list[l].name == nexting :         
								
									if object_list[k].flow  == 1 or object_list[k].statement_flow == 1 and object_list[l].flow != 0:
										object_list[l].flow = 1
										object_list[l].statement_flow = 1
		#alert("before draw3")					
		checked = 0
		del starts[:]
		#starts = list()                           
		for nexting in nextstates: 
			if nexting not in starts: 
				starts.append(nexting) 
		del nextstates[:]
#				if mode_graph == True:
	graphstr += '}'

	try:
						graphstr += "}"
						#d3 = window.d3

						svg2 = d3.select("#graph")
						svg2.append("p").graphviz().renderDot(graphstr)

	except:	
						pass        
#					open('lympha.dot', 'w').close()
#					outputfile = open("lympha.dot", "w")
#					outputfile.write(graphstr)
#					outputfile.close()
#					cmd = 'dot lympha.dot -Tps -o lympha.pdf'
#					os.system(cmd)
		
	CLI_filename = None
	argv_len = None
	filename = None
	filenames = None
	starts = None
	steps = None
	mode_graph = None
	mode_state = None
	filecheck = None
	mode_exe = None
	mode_show = None
	mode_map = None
	exe_list = None
	show_list = None
	map_list = None
	series = None
	substates = None
	nextstates = None
	specs = None
	global_relative_variable1 = None
	global_relative_variable2 = None
	operator1 = None
	statement_flow = None
	statement_value = None
	object_list = None
	exe_objects = None
	try:
		del CLI_filename, argv_len, filename, filenames, starts, steps, mode_graph, mode_state, filecheck, mode_exe, mode_show, mode_map, exe_list, show_list, map_list, substates, nextstates, specs, global_relative_variable1, global_relative_variable2, operator1, statement_flow, statement_value, exe_objects, object_list,
	except:
		pass
def stripComments(code):
	code = str(code)
	return re.sub(r'(?m)^ *#.*\n?', '', code)

def lexer():
	global CLIcom_segment
	global series
	global filenames
	global local_files
	#Load file content

######
	global object_list

	nexts = list()
	conts = list()
	#Make new nodes in database
	for serie in series:
#					document <= serie
# Strategy for splitting:
# words a-z A-Z 0-9
# space = - + \s ->
# 
# 
		prearrowobjs = serie.split('->')
		#arrowobjs = re.split('->|=|\+|\-',serie)
		arrowobjs = list()
		for anobj in prearrowobjs:
			almostdone = anobj.split('=')
			arrowobjs.append(almostdone[0])
		count = 0
    
		oops = str() #
		nexts = list()
		conts = list()
		specs = list()
		flow = int()
		global_relative_variable1 = float()
		operator1 = str()
       
		statement_flow = int()
		statement_value = str()
		scale = list()
		# Devide the script's line strings into objects:

		#print(object_list)

		pre_count = int(0)
		count_objs = int()                 
		###alert("60")
		for anobj in arrowobjs:
			anobj = re.sub("\s*", "", anobj) 
			##alert(anobj)
			eqobjs = re.compile(r"((<=)|(>=)|(!=)|(==)(<)|(>))").split(anobj)
			taken = 0
			#Check if the object already exists
			for takenkey in range(0,len(object_list)) :
				if object_list[takenkey].name == anobj :
					taken = 1
			
				#Avoid number gaps
				else:
					#Spin the list to the end
					pre_count += 1
			count_objs = pre_count
			#Add node at the end of the dicts
			#count_objs -= 1            
			if (anobj) != "" and taken == 0 :

				object_list[((count_objs))].name = str(anobj)

				object_list[((count_objs))].next_list = list()
				object_list[((count_objs))].binary_list = list()
				object_list[((count_objs))].operation = str("")
				object_list[((count_objs))].flow = 1
				object_list[((count_objs))].statement_flow = 1
				object_list[((count_objs))].statement_value = str()
				object_list[((count_objs))].global_relative_variable1 = float()
				object_list[((count_objs))].datatype = ""

	#Connect the database nodes     
	for serie in series:
		arrowobj = serie.split('->')
		count = 0
		nexts = list()
		conts = list()
		# Connect to the next object

		for i in range(0,len(arrowobj)):

			for key in range(0,len(object_list)):

				thename = str(object_list[key].name)
				thename = re.sub("\s*", "", thename) 
				if i != 0 :
					if thename == arrowobj[(0)].replace(" ",""):

						nexting = ""
						nexting = arrowobj[i].replace(" ","")
						if not nexting == "" :
							object_list[key].next_list.append(nexting)
						print(object_list[key].next_list)
						print(object_list[key].name)
	#Connect to depending objects:
	#Types of continuations of the side2 string:
	# 1. Operator + Sum of binaries
	# 2. Operator + Equation and value
	# 3. Constant value
	count = 0
	for serie in series:
		if " = " in serie :
			count = 0
			sides = serie.split(' = ')
			side1 = str(sides[0])
			side2 = str(sides[1])
			side1 = side1.replace(" ","")
			side2 = side2.replace(" ","")
			for key in range(0,len(object_list)) :
			#Web version TRY############
				try:
					thename = object_list[key].name
					if ("%s" % thename) == sides[0].replace(" ", "") :
						try:
							###alert("thename %s,  sides[0] %s" % (thename, sides[0]))
							#For binary values
							#if str("1B") in str(sides[1]) :           
							#elif re.compile(".*1B.*").match(sides[1]) :
									#object_list[key].statement_flow = 1
									#object_list[key].datatype = "bina"
							#elif str("0B") in str(sides[1]) :                 
							#elif re.compile(".*0B.*").match(sides[1]) :
									#object_list[key].statement_flow = 0   
									#object_list[key].datatype = "bina"
	
							#For evaluations
							# Check if operator:
							if ("==" in sides[1] or "!=" in sides[1] or "<=" in sides[1] or ">=" in sides[1] or "<" in sides[1] or ">" in sides[1] ) and not "->" in sides[1]:
							#eval_pattern = re.compile(r"(==)|(!=)|(<)|(>)|(<=)|(>=)")
							#if eval_pattern.match(sides[1]) :
	#                            if re.compile(".*==.*").match(sides[1]) :
									if "==" in (sides[1]) :
											object_list[key].operator1="equiv"
	#                            if re.compile(".*>=.*").match(sides[1]) :
									if ">=" in (sides[1]) :
											object_list[key].operator1="geq"
	#                            if re.compile(".*<=.*").match(sides[1]) :
									if "<=" in (sides[1]) :
											object_list[key].operator1="leq"
	#                            if re.compile(".*(!=).*").match(sides[1]) :
									if "!=" in (sides[1]) :
											object_list[key].operator1="no"
									if re.compile(".*>.*").match(sides[1]) and not re.compile(r"(>=)").match(sides[1]) :
											object_list[key].operator1="g"
									if re.compile(".*<.*").match(sides[1]) and not re.compile(r"(<=)").match(sides[1]) :
											object_list[key].operator1="l"
									print(object_list[key].operator1)
									preop = sides[1].replace(" ","")
									bin_chopped = 0
									if "\|{" in preop or "|{" in preop :
									#if "\|{" in preop and "}|" in preop :
										bin_chopped = 1
									preop = re.sub(r'(\|{)', ' ', preop)
									preop = re.sub(r'(}\|)', ' ', preop)                            
									#preop = preop.replace("}|","")
									#preop = re.sub("\|{","", preop)
									chopcompile = re.compile(r"(<=|>=|!=|==|<|>)")
									operator_chop = re.split(chopcompile, preop)
									###alert("operator_chop:[%s]" % operator_chop)
									#Tipping point
									zerochop = operator_chop[0].replace(" ","")
									object_list[key].global_relative_variable1 = zerochop 
									# chopped into binary list                                
									###alert("binvalue")
									if bin_chopped == 1 :
											###alert("check1")
											binary_sums = list(operator_chop[2].split(','))
											for binary in binary_sums:
												###alert("check2")
												binary = binary.replace(" ","")
												if binary != "" :
													###alert("check3")
													binary = str(binary.replace(" ",""))
													#object_list[key].binary_list += (str(binary)
													object_list[key].binary_list.append(str(binary))
												object_list[key].datatype = "bineval"
												#object_list[key].binary_list = list(the_bin_list)<
									elif bin_chopped == 0 :
											object_list[key].statement_value = operator_chop[2]
											object_list[key].datatype = "nonbineval"
	
							#For non-binary values and equations
							elif sides[0] != ""  and sides[1] != "" :
									print("YYY %s" % object_list[key].name)
								#if 0 == len(operator_chop) :
									object_list[key].statement_value = sides[1] 
									object_list[key].datatype = "valu"                               
						except:
							pass								
	
				except:
					pass
			count += 1          

def zcripts(ev):
	#alert("test")
	#Web version --- skip local files
	#Web version
	theturn = 1
	global object_list
	global series
	global addresses
	global starts
	global steps
	global modegraph
	global local_files
	global urls


	#for an_item in document.select(".theItems"):
	#	addresses.append(an_item.value)
	addresses.append("https://raw.githubusercontent.com/RickardHultgren/LYMPHA-scripts/master/COSMIC-scripts/anemia.lympha")	
	urls=list()
	for an_address in addresses:
		urls.append(urllib.request.urlopen(an_address).read())

	for j in urls:
		filetext = j
		filetext = stripComments(str(filetext))
		filetext = filetext.replace('\n', ' ')
		filetext = filetext.replace('  ', ' ')
		##alert(filetext)
		series.extend(filetext.split(';'))

	#document <= html.BR()			
	modegraph = True
	#document <= html.BR()				
	modegraph = True
	temporary_starts = list()
	steps = int(document['stepNr'].value)
	for start_item in document.select(".theStarts"):
		starts.append(start_item.value)
		temporary_starts.append(start_item.value)
	##alert(temporary_starts)
	lexer()
	#Preview
	prevwfunc()				        
	nextstates = list()
	theturn = 1
	#Finding objects in 
	factorform = document['factorlist']
	for start in temporary_starts :
		for k in range(0,len(object_list)):
			if object_list[k].name == start :
				object_list[k].flow = 1
				object_list[k].statement_flow = 1


	for ztep in range(0, int(steps)) :


		if theturn < 3:
			if len(temporary_starts) > 0 :
				for start in temporary_starts :

					for k in range(0,len(object_list)):
#Non lympha?
						###alert("aa4 [%s]" % object_list[k].name)
						#if object_list[k].name==start and (object_list[k].name[-1] == "?") :
						if object_list[k].name==start :
								#alert("supertest10")
								object_list[k].flow = 0 
								###alert("a1")
								object_list[k].statement_flow = 0 
								###alert("a2")
								###alert("a3")
								object_list[k].statement_flow = 0
								###alert("a4")									
								object_list[k].flow = 0
								###alert("a5")									
								factorform <= str("%s = "% object_list[k].name)
								if object_list[k].name[-10:] == "_decreased" or object_list[k].name[-10:] == "_increased" or object_list[k].name[-7:] == "_normal":
									factorform <= html.INPUT(Type="text", Id=(object_list[k].name),Class="factorItems",Value="1B")
								else:
									factorform <= html.INPUT(Type="text", Id=(object_list[k].name),Class="factorItems")
								factorform <= html.BR()
								theturn = 2
			

				#Loading the next starts from the current starts.
					if object_list[k].name==start :
						for nexting in object_list[k].next_list :
							for l in range(0,len(object_list)):  
								if object_list[l].name == nexting :          
									nextstates.append(nexting)
			else:
				factorform <= str("No matching variables in the script.")
		##alert("end1")
		#Make new starts. Should be done after each starts-loop
		del temporary_starts[:]
		for nexting in nextstates: 
			if nexting not in temporary_starts: 
				temporary_starts.append(nexting) 
		del nextstates[:]
         	#After each set of start loops a validation of theturn should be done.
		if theturn == 2:
			theturn = 3



def turn2func(ev) :
#The goal is to implement the first step factors
	global object_list
	###alert("begin1 %s" % document.select(".factorItems"))         
	for an_obj in range(0,len(object_list)): 
					####alert("begin2")
					for a_name in document.select(".factorItems"):
						try:	
							###alert("a_name.id:[%s] object_list[an_obj].name:[%s] a_name.value:[%s]" % (a_name.id, object_list[an_obj].name, a_name.value ))
							if a_name.id == object_list[an_obj].name and a_name.id != "" :
								object_list[an_obj].statement_value  = a_name.value
								if a_name.value == "1B" or  a_name.value == "0B" : 
									object_list[an_obj].datatype = "bina"
									object_list[an_obj].value = a_name.value
								elif nomen.isdigit() == True:
									object_list[an_obj].datatype = "valu"
									object_list[an_obj].value = a_name.value                        
								#else:
									#object_list[an_obj].datatype = "nonbineval"
						except:
							pass
# End results: name, statement_value, datatype:(bina, valu)
	###alert("the end")
	try:
		del starts[:]          
	except:
		pass
	try:
		for start_item in document.select(".theStarts"):
			starts.append(start_item.value)
			temporary_starts.append(start_item.value)
		##alert(starts)
	except:
		pass
         
	mapfunc()

def changeMenu(ev) :
	if (document.getElementById("menuish").style.display == 'block') :
		document.getElementById("menuish").style.display = 'none'
	else :
		document.getElementById("menuish").style.display = 'block'


     
def add_input(ev):
	aform = document['thelist']
	aform <= html.INPUT(type="text", Class="theItems")
	aform <= html.BR()


def add_start(ev):
	startform = document['thestarts']
	startform <= html.INPUT(type="text", Class="theStarts")
	startaform <= html.BR()

document["turn2"].bind("click", turn2func)
#document["addbttn"].bind("click", add_input)
#document["addstart"].bind("click", add_start)
document["zcriptbttn"].bind("click", zcripts)
#document["menubttn"].bind("click", changeMenu)

#document.getElementById( "index").style.backgroundColor='#EFAB00'
#document.getElementById( "indexsmall").style.backgroundColor='#EFAB00'
#document.getElementById( "index").style.color='#ffffff'
#document.getElementById( "index").className="index2active"

</script>
<h1 style="font-style:bold;font-size:2em;font-style:serif;">COSMIC-LYMPHA<br>För uträkning av vidarehandläggning baserat på LYMPHA-skript och lab-svar från COSMIC</h1>
<hr style="margin:0em 0em 1.5em 0em;border-color:#888;border-width:1px;background-color:#eeeeee;" >
Markera läkemdlentyperna av prov till vänster i lab-svars-modulen i COSMIC. Tryck Ctrl + C. Sätt markören i rutan "Provtyper" och trycka på Ctrl + V. Klicka sedan någonstans r tabellen med provsvar. Tryck sedan Ctrl + A och därefter Ctrl + C. Sätt markören i rutan "Provsvar" och trycka på Ctrl + V. Tryck sedan på knappen "Kalkylera".
<hr style="margin:0em 0em 1.5em 0em;border-color:#888;border-width:1px;background-color:#eeeeee;" >
<br>
<br>
Provtyper
<br>
<textarea cols="100" rows="10" style="margin:0em 0em 1.5em 0em;border-color:#000;border-width:1px;background-color:#eeeeee;" type="text" id="heads"> </textarea>
<br>
<br>
Provsvar
<br>
<textarea cols="100" rows="10" style="margin:0em 0em 1.5em 0em;border-color:#000;border-width:1px;background-color:#eeeeee;" type="text" id="thedata"> </textarea>
<br>

	<button id="calcbttn" type="submit" pys-onClick="calculate">
		Kalkylera
	</button>

<div id="assessment"></div>
	
<hr style="margin:0em 0em 1.5em 0em;border-color:#000;border-width:1px;background-color:#eeeeee;" />
				<form id="steps">
				
				  <b>Number of steps that should be taken:</b><br>
				  
				
				</form>
    <py-env>
    #- re
    </py-env>
    <py-script>
    from js import console
    def calculate(*args, **kwargs): 
        Element('assessment').element.innerText = ("test 1")
        headrows = list() 
        datarows = list()
        heads = str(Element('heads').element.value)
        headrows = heads.split("\n")
        thedata = str(Element('thedata').element.value)
        datarows = thedata.split("\n")
        rowspec = dict()
        rowsdata = dict()
        title = str()
        max = 0 
        min = 0
        #For data specifications:
        for rowidx, row in enumerate(headrows):
            title = str()
            intervall = str()
            Element('assessment').element.innerText = ("test 2")
            try:
              while row[0] == " " :
                row = row[1:]
                if row[0] != " " :
                    break
            except:
              pass
            Element('assessment').element.innerText = ("test 2.1")
            rowlist = row.split("\t")
            specific = dict()
            for idx, subitem in enumerate(rowlist):
                if idx == 0 :
                    title = subitem
                    specific["title"] = title
                if idx == 2 :
                  try:
                    intervall = subitem 
                    ilist = intervall.split("-")
                    specific["norm_min"] = int(ilist[0])
                    specific["norm_max"] = int(ilist[1])  
                  except:
                    pass
            rowspec[str(rowidx)] = specific                
            Element('assessment').element.innerText = ("test 2.2")
        #For table data:
        Element('assessment').element.innerText = ("test 2.3")
        for rowidx, row in enumerate(datarows):
            Element('assessment').element.innerText = ("test 3")
            try:
              while row[0] == " " :
                row = row[1:]
                if row[0] != " " :
                    break
            except:
              pass
            rowlist = row.split("\t")		

            for subitem in rowlist:
                done = 0
                if subitem == "" :
                    if done == 1 :
                        break
                    else:
                        pass
                else:
                    rowsdata[str(rowidx)]  = subitem            
                    done = 1
        Element('assessment').element.innerText = ("test 3.1")
        #Assessment:
        toprint = str()
        thestarts = document.querySelector('#thestarts')
        Element('assessment').element.innerText = ("test 3.2")
        for i in range(len(rowspec)):
            #try:
            Element('assessment').element.innerText = ("test 3.3")
            j = int(int(i))
            specific = rowspec[str(j)]
            #number = str(rowsdata[str(i)])
            #number = number.replace(" ", "")
            evaluation = str()
            Element('assessment').element.innerText = ("test 3.4")
            try:
              title = str(specific["title"])
              min = int(specific["norm_min"])
              max = int(specific["norm_max"])
            except:
              pass
            Element('assessment').element.innerText = ("test 3.5")
            try:
              intnumber = int(rowsdata[str(i)]) 
            except:
              pass
            Element('assessment').element.innerText = ("test 3.6")
            try:
              if   intnumber < min :
                evaluation="decreased"
                specific["evaluation"] = "decreased"
              elif intnumber > max :
                evaluation="increased"
                specific["evaluation"] = "increased"
              else:
                evaluation="normal"
                specific["evaluation"] = "normal"
            except:
              pass
            try:
              #Transform into binary LYMPHA-datatypes
              bintitle = title.replace("-","_")
              if specific["evaluation"] == "decreased":
                  bintitle = bintitle + "_decreased"
              elif specific["evaluation"] == "increased":
                  bintitle = bintitle + "_increased"
              elif specific["evaluation"] == "normal":
                  bintitle = bintitle + "_normal"
              start_element = document.createElement("input")
              start_element.value = bintitle
              start_element.className = "theStarts"
              thestarts.appendChild( start_element )            

            except:
              pass
            try:
              toprint = toprint + title + " ; min: " + str(min) + " ; max: " + str(max) + " ; value: " + str(intnumber) + " ; " + evaluation + "\n"
            except:
              pass
            #except:
            #pass


            Element('assessment').element.innerText = ("test 4")
							
        Element('assessment').element.innerText = (str(toprint))

        for i in range(len(rowspec)):
            #try:
            j = int(int(i))
            specific = rowspec[str(j)]
            #number = str(rowsdata[str(i)])
            #number = number.replace(" ", "")
            evaluation = str()
            title = str(specific["title"])
            min = int(specific["norm_min"])
            max = int(specific["norm_max"])
            intnumber = int(rowsdata[str(i)]) 
            if   intnumber < min :
                evaluation="too low"
            elif intnumber > max :
                evaluation="too high"
            else:
                evaluation="normal"

            Element('assessment').element.input = (str(title))

    </py-script>


			<div style="content">

		<div style="content">
			<p class="container" style="">		
		

				<!--img src="logo.png" style="width:25vw;">
				<h1>LYMPHA-online</h1-->
				<br>
				<br>

				
				<br><br>

				<!--form>
					<input type="radio" name="arg" value="" />Let the value of variables decide paths to be shown.<br>
					<input type="radio" name="arg" value="" />Let all the paths available be shown.<br>
				</form-->
				<!--br>
				<br-->
				<!--form>
					<input type="radio" name="out" value="" />Graph output.<br>
					<input type="radio" name="out" value="" />Step output.<br>
				</form-->	
				<b>Start nodes:</b>
				<form id="thestarts">
				  <!--input type="text" class="theStarts"/--><br>
				</form>
				<!--button id="addstart" >Add yet another start node</button--><br>
				
				<br>
				<br>

				<form id="steps">
				
				  <b>Number of steps that should be taken:</b><br>
				  <input type="text" id="stepNr" class="stepNr"/><br>
				
				</form>
				
				<br>
				<br>

				<button id="zcriptbttn">Check for variable factors</button><br>
				
				<hr style="width:50vw; right:25vw; z-index:1;position:relative; text-align:center;" />

				<form id="factorlist" style="border-width:0.25em;">
				  <!--input type="text" style="hidden" class="factorItems"></input-->
				</form>
				<button id="turn2">Implement variables into script</button><br>
				<hr style="width:50vw; right:25vw; z-index:1;position:relative; text-align:center;" />
				<span style="color:black;"><b>Result:</b><br></span>
				<form id="resultlist">
				  
				</form>
			</p>
		</div>



  
<div id="graphpreview" style="width: 900px; height: 900px; border: 1px solid black; backgroundColor:#ff0000"></div>

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>v

<div id="graph" style="width: 300px; height: 300px; border: 1px solid black; backgroundColor:#ff0000"></div>

	<script id="js">
//d3.select("#graph").append("p").graphviz().renderDot("digraph {a -> c}");;
//#    d3.select("#graph").append("p").graphviz().renderDot("digraph {a -> c}");
//#    d3.select("#graph").append("p").graphviz().renderDot('digraph {a -> c ; a -> b}');
	</script>

			
		
<br><br>


</body>
</html>
